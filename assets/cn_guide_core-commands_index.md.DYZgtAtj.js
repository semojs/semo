import{_ as e,v as s}from"./chunks/framework.CpxOrqDI.js";import"./chunks/theme.BuIvUvNz.js";const r=JSON.parse('{"title":"核心命令","description":"","frontmatter":{},"headers":[],"relativePath":"cn/guide/core-commands/index.md","filePath":"cn/guide/core-commands/index.md"}'),n={name:"cn/guide/core-commands/index.md"};function i(p,a,l,t,o,c){return s.openBlock(),s.createElementBlock("div",null,a[0]||(a[0]=[s.createStaticVNode(`<h1 id="核心命令" tabindex="-1">核心命令 <a class="header-anchor" href="#核心命令" aria-label="Permalink to &quot;核心命令&quot;">​</a></h1><h2 id="semo" tabindex="-1"><code>semo</code> <a class="header-anchor" href="#semo" aria-label="Permalink to &quot;\`semo\`&quot;">​</a></h2><p>请注意，<code>Semo</code> 提供了一种默认机制，可以运行任意符合 <code>Semo</code> 命令行文件语法规范的文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo command.js</span></span></code></pre></div><p>一般我们定义的命令都不会出现 <code>.js</code> 这样的扩展名，所以会按照命令的方式直接执行这个文件。如果需要执行 <code>.ts</code> 的命令文件风格，需要 <code>ts</code> 环境，请参考 FAQ 里的条目。</p><p>这种机制的意义何在，可以使用 <code>Semo</code> 来定义和执行脚本文件，也就是模糊了命令和脚本的概念，他们是相通的，先有脚本，如果觉得需要频繁使用，就起个好名字，然后封装成插件。早期的时候还封装了一个 <code>semo-plugin-script</code> 的插件，目的也是做这件事情，现在有了这个默认机制就可以内置对脚本文件的支持了。不过 <code>semo-plugin-script</code> 插件还有脚本样板代码生成器的功能，这个特性 <code>Semo</code> 核心并不打算提供。因为这里更倾向理解成是快速开发命令行工具的一个简化方式。</p><h2 id="semo-application" tabindex="-1"><code>semo application</code> <a class="header-anchor" href="#semo-application" aria-label="Permalink to &quot;\`semo application\`&quot;">​</a></h2><blockquote><p>alias: <code>app</code></p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这条命令已经转移到 <code>semo-plugin-application</code> 插件</p></div><p>默认这个命令没有任何功能，存在的意思是跟业务项目建立一个约定，建议业务项目添加的命令都写成这个命令的子命令。而业务项目之所以能为这个命令添加子命令是利用了 <code>Semo</code> 的命令扩展机制。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> semo-plugin-application</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">semo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> generate</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> command</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/test</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --extend=application</span></span></code></pre></div><p>这样就可以为项目添加一个 test 命令，而这个命令在执行的时候需要使用 <code>semo application test</code> 的方式来调用。</p><p>通过 <code>semo application help</code> 可以看到当前业务项目定义的所有顶级子命令，因为如果项目实现的命令过多，层次也多的话，一般我们很难记住所有命令和参数，所以帮助命令是我们经常要执行的。</p><h2 id="semo-cleanup" tabindex="-1"><code>semo cleanup</code> <a class="header-anchor" href="#semo-cleanup" aria-label="Permalink to &quot;\`semo cleanup\`&quot;">​</a></h2><blockquote><p>alias: clean</p></blockquote><p>这个命令用于清理一些 Semo 内部产生的文件，常见的有 repl 命令的历史， shell 命令的历史， repl 里临时下载的包，run 命令临时下载的包，以及全局插件目录。</p><p>目前提供了有限的扩展，只允许应用目录定义清理目录，不支持插件来添加清理目录，主要是为了安全性考虑。</p><h2 id="semo-config" tabindex="-1"><code>semo config</code> <a class="header-anchor" href="#semo-config" aria-label="Permalink to &quot;\`semo config\`&quot;">​</a></h2><p>我们可以通过核心内置的这个命令来查看和修改配置文件，可以操作当前项目的配置文件，也可以操作全局配置文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo config &lt;op&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Manage rc config</span></span>
<span class="line"><span></span></span>
<span class="line"><span>命令：</span></span>
<span class="line"><span>  semo config delete &lt;configKey&gt;                                Delete configs by key                     [aliases: del]</span></span>
<span class="line"><span>  semo config get &lt;configKey&gt;                                   Get configs by key</span></span>
<span class="line"><span>  semo config list                                              List configs                   [默认值] [aliases: ls, l]</span></span>
<span class="line"><span>  semo config set &lt;configKey&gt; &lt;configValue&gt; [configComment]     Set config by key</span></span>
<span class="line"><span>  [configType]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Options:</span></span>
<span class="line"><span>  --global, -g  For reading/writing configs from/to global yml rc file, default is false</span></span>
<span class="line"><span>  --watch       Watch config change, maybe only work on Mac</span></span></code></pre></div><p>注意，这里的 <code>&lt;configKey&gt;</code> 的格式是 <code>a.b.c</code> 的形式，代表多层级配置。另外，这里支持对设置的最后一个层级的配置添加注释。</p><h2 id="semo-hook" tabindex="-1"><code>semo hook</code> <a class="header-anchor" href="#semo-hook" aria-label="Permalink to &quot;\`semo hook\`&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这条命令已经转移到 <code>semo-plugin-hook</code> 插件</p></div><p>这个命令的输出显示了当前环境下可用的所有的钩子，所有实现这些钩子的逻辑都可以被执行。在输出当中能够看到钩子的名称，描述，以及钩子在哪个模块声明的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Hook                         :  Package :  Description</span></span>
<span class="line"><span>  hook_beforeCommand           :  semo    :  Hook triggered before command execution.</span></span>
<span class="line"><span>  hook_afterCommand            :  semo    :  Hook triggered after command execution.</span></span>
<span class="line"><span>  hook_component               :  semo    :  Hook triggered when needing to fetch component</span></span>
<span class="line"><span>  hook_hook                    :  semo    :  Hook triggered in hook command.</span></span>
<span class="line"><span>  hook_repl                    :  semo    :  Hook triggered in repl command.</span></span>
<span class="line"><span>  hook_status                  :  semo    :  Hook triggered in status command.</span></span>
<span class="line"><span>  hook_create_project_template :  semo    :  Hook triggered in create command.</span></span></code></pre></div><p>这里可以看到有一个特殊的钩子是 <code>hook_hook</code> 实现这个钩子就可以声明钩子，任何插件都可以声明自己的钩子，让其他命令来调用，从而影响自身的行为，一般业务项目是不需要声明自己的钩子的，除非业务项目深度使用了这个机制，来构成自己业务的插件系统。</p><p>另外需要注意的是，即使不声明，钩子也是可以被使用的，只要其被实现了，这里声明钩子只是为了透明。具体如何声明和实现钩子将在钩子相关小节说明。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>这里未来有可能改成不声明的钩子不让使用的逻辑</p></div><h2 id="semo-init" tabindex="-1"><code>semo init</code> <a class="header-anchor" href="#semo-init" aria-label="Permalink to &quot;\`semo init\`&quot;">​</a></h2><blockquote><p>alias: <code>i</code></p></blockquote><p>这个命令用来做初始化，可以实现两种场景，对业务项目的初始化或者对插件的初始化，这两个场景的差别在于目录结构稍有差异。</p><p>业务项目中，我们默认将 <code>Semo</code> 的目录结构放到 <code>bin</code> 目录:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>├── .semorc.yml</span></span>
<span class="line"><span>├── bin</span></span>
<span class="line"><span>│   └── semo</span></span>
<span class="line"><span>│       ├── commands</span></span>
<span class="line"><span>│       ├── extends</span></span>
<span class="line"><span>│       ├── hooks</span></span>
<span class="line"><span>│       ├── plugins</span></span>
<span class="line"><span>│       └── scripts</span></span>
<span class="line"><span>└── package.json</span></span></code></pre></div><p>而在插件项目中，我们是把所有代码放到 <code>src</code> 目录:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>├── .semorc.yml</span></span>
<span class="line"><span>├── src</span></span>
<span class="line"><span>│    ├── commands</span></span>
<span class="line"><span>│    ├── extends</span></span>
<span class="line"><span>│    ├── hooks</span></span>
<span class="line"><span>└── package.json</span></span></code></pre></div><p>这个命令存在的意义也仅仅是为了节省工程师若干秒的时间，也就是说如果不用这个命令，手动去创建这些目录和文件夹也是 OK 的。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>关于 <code>.semorc.yml</code> 的结构和用途将在配置管理小节说明</p></div><p>另外，如果我们真的要创建一个插件，通过初始化的方式进行还是太慢了，这里推荐使用插件项目模板进行，具体的命令如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo create semo-plugin-xxx --template=plugin</span></span></code></pre></div><p>很明显这里还可以使用其他项目模板，关于 <code>create</code> 命令，参见下放关于 <code>create</code> 命令的介绍。</p><h2 id="semo-create-name-repo-branch" tabindex="-1"><code>semo create &lt;name&gt; [repo] [branch]</code> <a class="header-anchor" href="#semo-create-name-repo-branch" aria-label="Permalink to &quot;\`semo create &lt;name&gt; [repo] [branch]\`&quot;">​</a></h2><blockquote><p>alias: <code>n</code></p></blockquote><p>这个命令和 <code>generate</code> 以及 <code>init</code> 都不一样，是用来初始化一个新的项目目录的，这个项目可以是业务项目，也可以是一个插件。这个命令有很多参数，也有一些约定：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ semo create help</span></span>
<span class="line"><span></span></span>
<span class="line"><span>semo create &lt;name&gt; [repo] [branch]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Create a create project from specific repo</span></span>
<span class="line"><span></span></span>
<span class="line"><span>选项：</span></span>
<span class="line"><span>  --version      显示版本号                                                                                       [布尔]</span></span>
<span class="line"><span>  --yes, -y      run npm/yarn init with --yes                                                             [默认值: true]</span></span>
<span class="line"><span>  --force, -F    force download, existed folder will be deleted!</span></span>
<span class="line"><span>  --merge, -M    merge config with exist project folder!</span></span>
<span class="line"><span>  --empty, -E    force empty project, ignore repo</span></span>
<span class="line"><span>  --template, -T   select from default repos</span></span>
<span class="line"><span>  --add, -A      add npm package to package.json dependencies                                            [默认值: false]</span></span>
<span class="line"><span>  --add-dev, -D  add npm package to package.json devDependencies                                         [默认值: false]</span></span>
<span class="line"><span>  --init-semo, -i     init new project</span></span>
<span class="line"><span>  -h, --help     显示帮助信息                                                                                     [布尔]</span></span></code></pre></div><p>单个的说明上面已经有了，下面我们用具体的使用场景说明一下</p><h3 id="从任意代码仓库初始化" tabindex="-1">从任意代码仓库初始化 <a class="header-anchor" href="#从任意代码仓库初始化" aria-label="Permalink to &quot;从任意代码仓库初始化&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo create PROJECT_NAME PROJECT_REPO_URL main -f</span></span></code></pre></div><p>这里可以看出，我们用 create 命令可以从任意 git 仓库地址下载代码，任何代码仓库都可以是我们的项目模板。其中 <code>main</code> 是分支名，默认就是 <code>main</code> 所以可以省略，<code>-f</code> 的意思是如果目录已经存在，会先删除原来的，再重新创建。</p><p>create 命令除了把代码下载下来，还帮着把原来的 <code>.git</code> 目录删除了，并且重新初始化了一个空的 <code>.git</code> 目录，然后把项目的依赖都自动下载下来了。</p><h3 id="创建一个空项目-不基于任何项目模板" tabindex="-1">创建一个空项目，不基于任何项目模板 <a class="header-anchor" href="#创建一个空项目-不基于任何项目模板" aria-label="Permalink to &quot;创建一个空项目，不基于任何项目模板&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo create PROJECT_NAME -yfie</span></span></code></pre></div><p>这里可以看到一个 <code>yargs</code> 的特性，可以把短参数连起来用，这里相当于 <code>-y -f -i -e</code>，也就是，<code>-y</code> 帮我们在创建了 <code>package.json</code>时自动回答 <code>yes</code>，<code>-f</code> 是强制删除已存在的目录，<code>-i</code> 是自动执行 <code>semo init</code> 初始化项目目录， <code>-e</code> 是告诉命令，即不基于代码仓库，也不基于内置模板，而是要声明一个空项目。</p><p>项目的目录结构如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>├── .semorc.yml</span></span>
<span class="line"><span>├── bin</span></span>
<span class="line"><span>│   └── semo</span></span>
<span class="line"><span>│       ├── commands</span></span>
<span class="line"><span>│       ├── extends</span></span>
<span class="line"><span>│       ├── hooks</span></span>
<span class="line"><span>│       ├── plugins</span></span>
<span class="line"><span>│       └── scripts</span></span>
<span class="line"><span>└── package.json</span></span></code></pre></div><h3 id="创建一个-semo-插件目录" tabindex="-1">创建一个 <code>Semo</code> 插件目录 <a class="header-anchor" href="#创建一个-semo-插件目录" aria-label="Permalink to &quot;创建一个 \`Semo\` 插件目录&quot;">​</a></h3><p>如果不基于插件模板，我们可以手动创建一个基本的插件结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo create semo-plugin-[PLUGIN_NAME] -yfie</span></span></code></pre></div><p>可以看到，和上面很类似，除了项目名，这里存在一个项目名称的约定，如果项目名称以 <code>semo-plugin-</code> 开头，则认为是在初始化一个 <code>Semo</code> 插件，初始化时会执行 <code>semo init --plugin</code>。</p><p>项目的目录结构如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>├── .semorc.yml</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>└── src</span></span>
<span class="line"><span>    ├── commands</span></span>
<span class="line"><span>    ├── extends</span></span>
<span class="line"><span>    └── hooks</span></span></code></pre></div><h3 id="基于内置模板创建项目" tabindex="-1">基于内置模板创建项目 <a class="header-anchor" href="#基于内置模板创建项目" aria-label="Permalink to &quot;基于内置模板创建项目&quot;">​</a></h3><p>如果我们创建项目执行下面的命令:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo create PROJECT_NAME --template</span></span></code></pre></div><p>则会看到下面的输出:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>? Please choose a pre-defined repo to continue: (Use arrow keys)</span></span>
<span class="line"><span>❯ semo_plugin_starter [semo-plugin-starter, plugin]</span></span>
<span class="line"><span>❯ ...</span></span></code></pre></div><p>这里可以选择一个想要选择的内置模板，也就是不用主动输入仓库地址了，这里默认只有一个插件模板，但是可以使用 <code>hook_create_project_template</code> 注入其他模板地址进去：</p><p>钩子实现示例，更多关于钩子的用法，请参见钩子相关说明</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hook_create_project_template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  demo_repo: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    repo: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;demo_repo.git&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    branch: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;main&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    alias: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;demo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果在初始化的时候已经知道要使用的模板和标识，可以直接指定：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo create PROJECT_NAME --template=demo</span></span>
<span class="line"><span>semo create PROJECT_NAME --template=demo_repo</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在创建业务项目或者插件时，不推荐从空项目开始，因为还要考虑很多工程化的问题，技术选型的问题，推荐归纳总结自己公司常用的脚手架项目，然后通过统一的方式进行初始化。比如内置的插件模板，初始化后，可以直接编写逻辑，然后代码上传到 <code>Github</code> 再执行 <code>npm version patch &amp;&amp; npm publish</code> 即可发布到 npm 仓库了。关于如何开发一个插件并且发布到 <code>npm</code> 仓库，会单独写文档说明。另外，需要注意，这里的脚手架项目可以是任意语言实现的。</p></div><p><code>--add</code> 和 <code>--add-dev</code> 用来在初始化时指定新的依赖包。<code>--merge</code> 是说不删除原来的项目，而是进入项目目录，然后应用 <code>--init</code>, <code>--add</code>, <code>--add-dev</code>。</p><h2 id="semo-generate-component" tabindex="-1"><code>semo generate &lt;component&gt;</code> <a class="header-anchor" href="#semo-generate-component" aria-label="Permalink to &quot;\`semo generate &lt;component&gt;\`&quot;">​</a></h2><blockquote><p>alias: <code>generate</code>, <code>g</code></p><p>这个命令是一个组件代码生成命令，这里组件的意思是对开发目标进行抽象的后的分层分类概念，比如 <code>Semo</code> 核心就定义了插件，命令和脚本3个概念，所以这三个概念有对应的代码生成子命令，同样的，<code>semo</code> 插件或者集成的项目都可以创建自己的抽象概念，并提供配套的代码生成器，比如业务项目后端会有路由，控制器，模型，数据库迁移文件，单元测试等概念，这些概念由于项目的不同可能是不通用的，但是一个项目内部最好风格保持一致，通过自动生成样板代码可以更好的保持风格一致。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ semo generate help</span></span>
<span class="line"><span></span></span>
<span class="line"><span>semo generate &lt;component&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Generate component sample code</span></span>
<span class="line"><span></span></span>
<span class="line"><span>命令：</span></span>
<span class="line"><span>  semo generate command &lt;name&gt; [description]               Generate a command template</span></span>
<span class="line"><span>  semo generate plugin &lt;name&gt;                              Generate a plugin structure</span></span>
<span class="line"><span>  semo generate script &lt;name&gt;                              Generate a script file</span></span>
<span class="line"><span></span></span>
<span class="line"><span>选项：</span></span>
<span class="line"><span>  --version   显示版本号                                                                                          [布尔]</span></span>
<span class="line"><span>  -h, --help  显示帮助信息                                                                                        [布尔]</span></span></code></pre></div><h3 id="扩展-generate-命令添加子命令" tabindex="-1">扩展 <code>generate</code> 命令添加子命令 <a class="header-anchor" href="#扩展-generate-命令添加子命令" aria-label="Permalink to &quot;扩展 \`generate\` 命令添加子命令&quot;">​</a></h3><p>和上面扩展 <code>application</code> 命令的方法是一样的：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">semo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> generate</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> command</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> generate/test</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --extend=semo</span></span></code></pre></div><p>具体怎么实现这些代码生成命令，这里是没有做约束的，因为首先 es6 内置的模板字符串机制可以解决大多数问题，然后 <code>lodash</code> 其 <code>_.template</code> 方法也比较灵活，最后只要把组装好的样板代码放到想放的位置即可。</p><p>因为这部分都是基于 <code>Semo</code> 的，所以相关的配置建议放到 <code>.semorc.yml</code> 文件，例如自动生成的配置里就有的：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">commandDir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">src/commands</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">extendDir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">src/extends</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">hookDir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">src/hooks</span></span></code></pre></div><p>可以看到，<code>create</code> 命令生成默认配置也仅仅是约定了一些代码自动生成的目录，同时也给出一种定义目录的配置风格，如果想保持配置的一致性，可以用同样的风格定义其他目录。</p><h2 id="semo-plugin" tabindex="-1"><code>semo plugin</code> <a class="header-anchor" href="#semo-plugin" aria-label="Permalink to &quot;\`semo plugin\`&quot;">​</a></h2><blockquote><p>alias: p</p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这条命令已经转移到 <code>semo-plugin-plugin</code> 插件</p></div><p>这个命令用于安装在家目录的全局插件，也可以用于优化当前项目的 semo 执行效率。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ semo plugin help</span></span>
<span class="line"><span>semo plugin</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Plugin management tool</span></span>
<span class="line"><span></span></span>
<span class="line"><span>命令：</span></span>
<span class="line"><span>  semo p install &lt;plugin&gt;    Install plugin                                                                 [aliases: i]</span></span>
<span class="line"><span>  semo p list                List all plugins                                                           [aliases: l, ls]</span></span>
<span class="line"><span>  semo p uninstall &lt;plugin&gt;  Uninstall plugin                                                              [aliases: un]</span></span></code></pre></div><h2 id="semo-repl-replfile" tabindex="-1"><code>semo repl [replFile]</code> <a class="header-anchor" href="#semo-repl-replfile" aria-label="Permalink to &quot;\`semo repl [replFile]\`&quot;">​</a></h2><blockquote><p>alias: <code>r</code></p></blockquote><p>REPL(read-eval-print-loop)：交互式解析器，每一个现代的编程语言大概都有这类交互环境，在里面我们可以写一些简单的代码，做为一个快速了解和学习语言特性的工具。但是当 REPL 可以和框架或者业务项目结合以后，可以发挥出更大的作用。</p><h3 id="对-repl-的一些扩展" tabindex="-1">对 <code>REPL</code> 的一些扩展 <a class="header-anchor" href="#对-repl-的一些扩展" aria-label="Permalink to &quot;对 \`REPL\` 的一些扩展&quot;">​</a></h3><p>在开发Semo 和这个脚手架时，Node 的 REPL 还不支持 <code>await</code>，这里是模拟实现了这个机制，目的是可以触发执行项目中的一些 promise 或 generator 方法。通过这个能力，再加上我们可以把一些业务代码注入到 <code>REPL</code> 我们就可以在接口控制器，脚本，单元测试之外多了一种执行方式，而这种执行方式还是交互式的。</p><h3 id="为-repl-注入新的对象" tabindex="-1">为 <code>REPL</code> 注入新的对象 <a class="header-anchor" href="#为-repl-注入新的对象" aria-label="Permalink to &quot;为 \`REPL\` 注入新的对象&quot;">​</a></h3><p>这里需要实现内置的 <code>hook_repl</code> 钩子，并且在业务项目的声明的钩子目录配置： <code>hookDir</code>，下面代码仅供参考。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/hooks/index.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hook_repl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  semo: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    multiple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后在 REPL 环境，就可以使用了:</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>hook_repl</code> 返回的信息都注入到了 REPL 里的 Semo.hooks.application。</p></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt;&gt;&gt; Semo.hooks.application.add</span></span>
<span class="line"><span>[Function: add]</span></span>
<span class="line"><span>&gt;&gt;&gt; await Semo.add(1, 2)</span></span>
<span class="line"><span>3</span></span>
<span class="line"><span>&gt;&gt;&gt; Semo.hooks.application.multiple</span></span>
<span class="line"><span>[Function: multiple]</span></span>
<span class="line"><span>&gt;&gt;&gt; await Semo.multiple(3, 4)</span></span>
<span class="line"><span>12</span></span></code></pre></div><p>在实际的业务项目中，会把项目中的公共方法，工具函数等等都注入进去，这对开发以及后面的排查问题都是很有帮助的。默认 <code>Semo</code> 把自己的运行时对象注入进去了，比如 Semo.argv。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在具体的实践中，我们把数据库，缓存，OSS，Consul, ElasticSearch 等等多种公司的基础设施注入了进来，写成插件，使得我们更容易的直接访问基础设施。</p></div><h3 id="重新载入一遍钩子文件" tabindex="-1">重新载入一遍钩子文件 <a class="header-anchor" href="#重新载入一遍钩子文件" aria-label="Permalink to &quot;重新载入一遍钩子文件&quot;">​</a></h3><p><code>.reload</code> 或者 <code>Semo.reload()</code> 可以重新执行一遍 <code>hook_repl</code> 钩子，然后把最新的结果注入 Semo。这个的用途是希望在不退出 REPL 环境的情况下能够调用最新的钩子结果，这里只能保证重新加载和执行钩子文件本身，如果钩子内部用了 <code>require</code> 还是会被缓存，这部分就需要用户自己来处理了，比如每次 <code>require</code> 之前先尝试删除 <code>require.cache</code></p><h3 id="临时试用-npm-包" tabindex="-1">临时试用 npm 包 <a class="header-anchor" href="#临时试用-npm-包" aria-label="Permalink to &quot;临时试用 npm 包&quot;">​</a></h3><p>在 REPL 下支持用 <code>Semo.import</code> 临时下载和调试一些包，这个调试包下载不会进入当前项目的 node_modules 目录。(还有一个等价方法是：Semo.require)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt;&gt;&gt; let _ = Semo.import(&#39;lodash&#39;)</span></span>
<span class="line"><span>&gt;&gt;&gt; _.VERSION</span></span></code></pre></div><h4 id="使用内部命令的方式" tabindex="-1">使用内部命令的方式 <a class="header-anchor" href="#使用内部命令的方式" aria-label="Permalink to &quot;使用内部命令的方式&quot;">​</a></h4><blockquote><p>v1.5.14 新增 <code>.require</code> 和 <code>.import</code> 是等价的，可以快速导入一些常用包用于调试，例如：</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt;&gt;&gt; .import lodash:_ dayjs:day</span></span></code></pre></div><p>冒号后面的是别名，意思是导入后存成什么变量名。</p><h3 id="释放对象的属性到-repl-环境" tabindex="-1">释放对象的属性到 REPL 环境 <a class="header-anchor" href="#释放对象的属性到-repl-环境" aria-label="Permalink to &quot;释放对象的属性到 REPL 环境&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt;&gt;&gt; Semo.extract(Semo, [&#39;hooks.application.add&#39;, &#39;hooks.application.multiple&#39;])</span></span></code></pre></div><p>这个操作的潜在风险就是会覆盖 REPL 环境里内置的对象，但是这个 API 的目的和作用是释放一些明确的对象，比如从 ORM 里释放一个数据库中所有的表模型。</p><p>这个操作也支持在配置中进行，比如要将 Semo 对象里的 <code>Utils</code> 注入进去，可以在配置文件中配置：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$plugin:</span></span>
<span class="line"><span>  semo:</span></span>
<span class="line"><span>    repl:</span></span>
<span class="line"><span>      hook: true</span></span>
<span class="line"><span>      extract:</span></span>
<span class="line"><span>        Semo:</span></span>
<span class="line"><span>          - hooks.application.add</span></span>
<span class="line"><span>          - hooks.application.multiple</span></span></code></pre></div><p>如果只想注入 <code>Utils</code>，支持这么写。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$plugin:</span></span>
<span class="line"><span>  semo:</span></span>
<span class="line"><span>    extract:</span></span>
<span class="line"><span>      Semo: [Utils]</span></span></code></pre></div><h3 id="semo-对象简介" tabindex="-1">Semo 对象简介 <a class="header-anchor" href="#semo-对象简介" aria-label="Permalink to &quot;Semo 对象简介&quot;">​</a></h3><p>最早的时候本来打算核心和插件可以自由的注入到 REPL 环境，后来觉得不可控，所以决定核心和插件都只能注入到 <code>Semo</code> 对象。下面说一下 Semo 对象的结构</p><ul><li>Semo.hooks 为了对各个插件的信息进行隔离，所有插件注入的信息按照插件名称注入到这里，各个插件不会相互干扰</li><li>Semo.argv 这个是进入命令的 <code>yargs</code> argv参数，有时可以用于看看配置合并是否生效，以及实验 yargs 的参数解析。</li><li>Semo.repl 当前 REPL 环境的对象实例</li><li>Semo.Utils 核心工具包，里面除了自定义的若干函数之外 等</li><li>Semo.reload 重新执行 <code>hook_repl</code> 钩子，使用最新的钩子文件</li><li>Semo.import 用于临时实验一些 npm 包， 可以用 <code>semo cleanup</code> 清理缓存</li><li>Semo.extract 用于释放内部对象的键值到当前作用域，可以算作是把所有钩子的注入都放到 <code>Semo.hooks</code> 对象的一个补偿</li></ul><h3 id="注入到全局作用域的三个方法" tabindex="-1">注入到全局作用域的三个方法 <a class="header-anchor" href="#注入到全局作用域的三个方法" aria-label="Permalink to &quot;注入到全局作用域的三个方法&quot;">​</a></h3><p>如果觉得默认的对象层次比较深，可以通过配置或者参数使得默认注入到 REPL 的全局作用域。</p><h4 id="方式一-是-extract-选项" tabindex="-1">方式一：是 <code>--extract</code> 选项 <a class="header-anchor" href="#方式一-是-extract-选项" aria-label="Permalink to &quot;方式一：是 \`--extract\` 选项&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo repl --extract Semo.hooks</span></span></code></pre></div><h4 id="方式二-是配置-修改-semorc-yml" tabindex="-1">方式二：是配置: 修改 <code>.semorc.yml</code> <a class="header-anchor" href="#方式二-是配置-修改-semorc-yml" aria-label="Permalink to &quot;方式二：是配置: 修改 \`.semorc.yml\`&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$plugin:</span></span>
<span class="line"><span>  semo:</span></span>
<span class="line"><span>    extract: Semo.hooks.application</span></span></code></pre></div><h4 id="方式三-是在-repl-里执行-semo-extract" tabindex="-1">方式三：是在 REPL 里执行 Semo.extract <a class="header-anchor" href="#方式三-是在-repl-里执行-semo-extract" aria-label="Permalink to &quot;方式三：是在 REPL 里执行 Semo.extract&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt;&gt;&gt; Semo.extract(Semo, [&#39;hooks.application.add&#39;, &#39;hooks.application.multiple&#39;])</span></span></code></pre></div><p>Semo.extract 很灵活，可以指定要导出哪些 key，也可以留空，默认导出所有的 key。</p><h3 id="支持执行一个repl文件" tabindex="-1">支持执行一个repl文件 <a class="header-anchor" href="#支持执行一个repl文件" aria-label="Permalink to &quot;支持执行一个repl文件&quot;">​</a></h3><p>用途也是执行逻辑后将一些结果注入到REPL，文件也是Node模块，需要符合指定格式。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或者</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>既可以通过 context 添加，也可以返回一个对象来添加。</p><p>这个机制有什么作用呢？主要用途是在我们开发调试时，有一些想在REPL里进行的调试是有许多前置逻辑的，如果都在REPL里一行一行的输入太麻烦，所以通过这种方式就可以把调试逻辑固化下来。</p><p>repl 文件和 extract 的区别在于，extract 只能操作已经存在的对象，而 repl 文件可以添加任何需要的对象到 REPL，从这个角度讲，类似于 hook_repl，并且操作起来更加方便，不需要考虑钩子实现的格式。</p><h2 id="semo-run-plugin-command" tabindex="-1"><code>semo run &lt;PLUGIN&gt; [COMMAND]</code> <a class="header-anchor" href="#semo-run-plugin-command" aria-label="Permalink to &quot;\`semo run &lt;PLUGIN&gt; [COMMAND]\`&quot;">​</a></h2><p>这个命令可以像 pnpm create 一样，实现直接执行远程插件包里的命令的效果</p><p>例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo run semo-plugin-serve serve</span></span></code></pre></div><p>这里是调用了 semo-plugin-serve 插件实现简单的 HTTP 服务，也许我们会觉得这样写起来还是不是很方便，那么我们可以简化一下。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo run serve</span></span></code></pre></div><p>这样看是不是简洁多了，这里能把 <code>semo-plugin-</code> 省略的原因是这里只支持 semo 系列插件，而不是所有的 npm 包，所以可以内部帮着加上，而后面的 serve 命令去掉是因为插件为此实现了一个约定，插件就是一个普通的 node 包，可以对外暴露方法，这里暴露了一个 handler 方法，而这个 handler 方法又去掉了包里的 serve 命令，因为这个命令文件也是一个 Node 模块。如果插件里面包含多个命令，可以用这个机制对外暴露最常用的，其他的还是应该明确传参。另外，需要注意的是一些命令需要传递参数，这里需要把所有的参数和选项都改造成选项。</p><p>之前是命令的时候：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo serve [publicDir]</span></span></code></pre></div><p>在用 <code>run</code> 命令调度时：注意，插件命令里的参数需要放到 <code>--</code> 后</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo run serve -- --public-dir=.</span></span></code></pre></div><p>如果你在 npm 的 semo 插件包也是在 scope 下的，在用 run 时需要指定 scope</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo run xxx --scope yyy</span></span></code></pre></div><p><code>run</code> 命令运行的插件肯定是缓存到本地了，只不过不在全局插件目录 <code>.semo/node_modules</code>, 而是在 <code>.semo/run_plugin_cache/node_modules</code> 目录，默认如果存在就会用缓存里的插件，如果想更新需要用参数 --upgrade</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo run serve --force</span></span></code></pre></div><p>有些插件可能依赖于另一些插件，如果有这种情况，就需要手动指定依赖插件，实现一起下载，为什么不能基于 npm 的依赖关系呢，可以看一下下面这个例子：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>此特性 v0.8.2 引入</p></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo run read READ_URL --format=editor --with=read-extend-format-editor</span></span></code></pre></div><p>editor 这个插件在开发时是依赖于 read 的，但是在运行时，read 指定的参数却是 editor 这个插件实现的，所以只能手动指定依赖了。</p><h2 id="semo-script-file" tabindex="-1"><code>semo script [file]</code> <a class="header-anchor" href="#semo-script-file" aria-label="Permalink to &quot;\`semo script [file]\`&quot;">​</a></h2><blockquote><p>alias: <code>scr</code></p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这条命令已经转移到 <code>semo-plugin-script</code> 插件</p></div><p>很多时候我们都需要跑一些脚本，这些脚本是在项目服务之外的，需要我们主动触发，可能是做数据迁移，可能是数据导出，可能是数据批量修改，也可能是执行业务逻辑，比如发邮件，发短信，发通知等等。在遇到这样的需求的时候，我们都需要写脚本，但是我们会遇到几个问题：</p><ul><li>放哪里</li><li>怎么写</li><li>脚本参数怎么解析</li></ul><p>很多时候这些需求都是一次性的，或者有前提的，不是很适合写成命令，不然命令就太多了，在这种场景下，<code>Semo</code> 通过这条命令给出了一个统一的方案。</p><h3 id="放哪里" tabindex="-1">放哪里 <a class="header-anchor" href="#放哪里" aria-label="Permalink to &quot;放哪里&quot;">​</a></h3><p>在配置中有一个 <code>scriptDir</code>，默认是 <code>src/scripts</code>，我们默认把脚本都放到这里，因为这些脚本不会被服务访问到，所以没必要和项目核心逻辑放的太近。</p><h3 id="怎么写-怎么解析参数" tabindex="-1">怎么写，怎么解析参数 <a class="header-anchor" href="#怎么写-怎么解析参数" aria-label="Permalink to &quot;怎么写，怎么解析参数&quot;">​</a></h3><p>当然可以手动建脚本，然后用这个命令来触发，但是因脚本还需要起名字，而且还有一定的格式要求，所以，推荐使用 <code>semo generate script</code> 命令来生成。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo generate script test</span></span></code></pre></div><p>自动生成的样板代码及文件名：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/bin/semo/scripts/20191025130716346_test.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> builder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">yargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // yargs.option(&#39;option&#39;, {default, describe, alias})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Start to draw your dream code!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可以看到，作为一个脚本，不是一上来就写业务逻辑，也不需要声明 <code>shebang</code> 标识，只需要定义两个方法，一个是 <code>builder</code>，一个是 <code>handler</code>。其中 <code>builder</code> 用于声明脚本的参数，格式可以参考 <code>yargs</code>，如果脚本不需要参数，其实也可以不定义，由于是模板自动生成，放到那里即可，以备不时之需。<code>handler</code> 是具体的执行逻辑，传入的参数就是解析好的脚本参数，也包含了项目的 <code>.semorc.yml</code> 里的配置。可以看到 <code>handler</code> 支持 <code>async</code> 所以这里可以执行一些异步操作。</p><p>所以，脚本和命令最大的区别其实就是使用的频率，以及业务的定位，我们经常做的分层是定义原子命令，然后在脚本中调度。</p><h2 id="semo-shell" tabindex="-1"><code>semo shell</code> <a class="header-anchor" href="#semo-shell" aria-label="Permalink to &quot;\`semo shell\`&quot;">​</a></h2><blockquote><p>alias: <code>sh</code></p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这条命令已经转移到 <code>semo-plugin-shell</code> 插件</p></div><p>这个命令是个很简单的命令，目的是不用每次敲命令都输入前面的 <code>semo</code>，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo shell</span></span>
<span class="line"><span>&gt; status</span></span>
<span class="line"><span>&gt; hook</span></span>
<span class="line"><span>&gt; repl</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo shell --prefix=git</span></span>
<span class="line"><span>&gt; log</span></span>
<span class="line"><span>&gt; remote -v</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo: prefix=git</span></span>
<span class="line"><span>git: log</span></span></code></pre></div><h2 id="semo-status" tabindex="-1"><code>semo status</code> <a class="header-anchor" href="#semo-status" aria-label="Permalink to &quot;\`semo status\`&quot;">​</a></h2><blockquote><p>alias: <code>st</code></p></blockquote><p>这个命令的作用很简单，就是看 <code>Semo</code> 当前所处的环境，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ semo st</span></span>
<span class="line"><span>  version  :  1.8.17</span></span>
<span class="line"><span>  location :  ~/.nvm/versions/node/[VERSION]/lib/node_modules/semo</span></span>
<span class="line"><span>  os       :  macOS 10.15</span></span>
<span class="line"><span>  node     :  8.16.2</span></span>
<span class="line"><span>  npm      :  6.4.1</span></span>
<span class="line"><span>  hostname :  [MY_HOST]</span></span>
<span class="line"><span>  home     :  [MY_HOME]</span></span>
<span class="line"><span>  shell    :  [MY_SHELL]</span></span></code></pre></div><p>这里实现了一个 hook， <code>hook_status</code>，实现了这个 hook 的插件，可以在这里展示插件的相关信息，如果是业务项目实现了这个钩子，也可以在这里显示项目信息。</p><h2 id="semo-completion" tabindex="-1"><code>semo completion</code> <a class="header-anchor" href="#semo-completion" aria-label="Permalink to &quot;\`semo completion\`&quot;">​</a></h2><p>这个命令的作用是输出一段 <code>Shell</code> 脚本，放到 <code>.bashrc</code> 或者 <code>.zshrc</code> 里，就能够获得子命令的自动补全效果。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eval</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">semo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> completion)&quot;</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>由于 Semo 在执行时是实时扫描各个层级的插件定义的命令，所以一点环境中插件和命令过多，Semo 执行起来会比较慢，这种情况就不建议把 completion 放到 <code>.bashrc</code> 或者 <code>.zshrc</code> 里了。</p></div>`,184)]))}const k=e(n,[["render",i]]);export{r as __pageData,k as default};
