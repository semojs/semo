import{_ as o,v as e}from"./chunks/framework.DjH-L2p3.js";import"./chunks/theme.4SiW67fZ.js";const m=JSON.parse('{"title":"如何贡献","description":"","frontmatter":{},"headers":[],"relativePath":"community/contrib/index.md","filePath":"community/contrib/index.md"}'),t={name:"community/contrib/index.md"};function r(i,a,n,d,c,l){return e.openBlock(),e.createElementBlock("div",null,a[0]||(a[0]=[e.createStaticVNode('<h1 id="如何贡献" tabindex="-1">如何贡献 <a class="header-anchor" href="#如何贡献" aria-label="Permalink to &quot;如何贡献&quot;">​</a></h1><h2 id="采纳和使用" tabindex="-1">\b采纳和使用 <a class="header-anchor" href="#采纳和使用" aria-label="Permalink to &quot;\b采纳和使用&quot;">​</a></h2><p>关于如果规范命令行实现方式，当然有很多种选择，而且总得来说，肯定是规范比不规范要强，如果你的团队已经有了自己的规范，那大可不比选择 <code>Semo</code> 这套规范，但是如果团队之前没有对命令行进行规范，不妨试试。如果你恰好也比较看好 <code>yargs</code>，那 <code>Semo</code> 的一些思路对你也可能有借鉴意义。</p><p><code>Semo</code> 可以用在很多地方，开发，测试，部署，运维，甚至是非业务场景，比如爬虫...</p><h2 id="编写文档" tabindex="-1">编写文档 <a class="header-anchor" href="#编写文档" aria-label="Permalink to &quot;编写文档&quot;">​</a></h2><p><code>Semo</code> 的文档需要在大家的帮助下逐渐完善，有一些使用技巧文档中可能还没有提及，欢迎大家基于探索，并分享你的发现。</p><h2 id="编写插件" tabindex="-1">编写插件 <a class="header-anchor" href="#编写插件" aria-label="Permalink to &quot;编写插件&quot;">​</a></h2><p>这里的插件分两种，一种是可以在企业级项目中扮演沉淀技术的角色，把常用的操作和逻辑封装成插件；另一种是个人创意插件，业务无关，可以实现和共享一些创意作品。</p><h2 id="贡献代码" tabindex="-1">贡献代码 <a class="header-anchor" href="#贡献代码" aria-label="Permalink to &quot;贡献代码&quot;">​</a></h2><p>不管是在业务项目中使用还是比啊捏创意插件，或者参与核心功能的开发都是很好的回馈社区的方式。</p><h2 id="帮助发现问题" tabindex="-1">帮助发现问题 <a class="header-anchor" href="#帮助发现问题" aria-label="Permalink to &quot;帮助发现问题&quot;">​</a></h2><p>不管是代码还是文档，都有可能隐藏了很多没被发现的问题，比如代码过时，文档错别字，由于不断改进和升级，导致部分文档失真，这些都需要大家用共建的方式来维护和改进。</p>',12)]))}const p=o(t,[["render",r]]);export{m as __pageData,p as default};
