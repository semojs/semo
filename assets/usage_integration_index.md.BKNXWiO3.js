import{_ as a,v as e}from"./chunks/framework.CAE459Ah.js";import"./chunks/theme.BJ09EcjL.js";const h=JSON.parse('{"title":"Project Integration","description":"","frontmatter":{},"headers":[],"relativePath":"usage/integration/index.md","filePath":"usage/integration/index.md"}'),i={name:"usage/integration/index.md"};function o(n,t,s,r,c,d){return e.openBlock(),e.createElementBlock("div",null,t[0]||(t[0]=[e.createStaticVNode('<h1 id="project-integration" tabindex="-1">Project Integration <a class="header-anchor" href="#project-integration" aria-label="Permalink to &quot;Project Integration&quot;">​</a></h1><p>Integrating with existing business projects was the original intention of <code>Semo</code>&#39;s development. If a project already has a custom command-line tool that works well, careful consideration should be given to whether switching to the <code>Semo</code> style is necessary. Fortunately, <code>Semo</code> integration is relatively simple. If the project previously lacked command-line infrastructure, trying <code>Semo</code> is recommended.</p><h2 id="why-integrate" tabindex="-1">Why Integrate <a class="header-anchor" href="#why-integrate" aria-label="Permalink to &quot;Why Integrate&quot;">​</a></h2><ul><li>Gain command-line infrastructure. A project always has some operations that are unsuitable for or haven&#39;t been implemented in the backend. A command-line tool allows for simpler interaction with the system and data.</li><li>Gain script infrastructure. There are always scripts that need execution. Common requirements include determining script names, locations, and how they interact with business logic or data.</li><li>Utilize relevant <code>Semo</code> plugins and influence/change their behavior through configuration.</li><li>Obtain a business-related <code>REPL</code> environment, allowing arbitrary calls to encapsulated methods within the project or interaction with encapsulated infrastructure.</li></ul><h2 id="project-integration-methods" tabindex="-1">Project Integration Methods <a class="header-anchor" href="#project-integration-methods" aria-label="Permalink to &quot;Project Integration Methods&quot;">​</a></h2><p>Not all features may be necessary; use them as needed.</p><h3 id="_1-add-semo-as-a-project-dependency" tabindex="-1">1. Add <code>Semo</code> as a project dependency <a class="header-anchor" href="#_1-add-semo-as-a-project-dependency" aria-label="Permalink to &quot;1. Add `Semo` as a project dependency&quot;">​</a></h3><p>Here&#39;s an example using <code>pnpm</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pnpm add -g @semo/cli</span></span></code></pre></div><h3 id="_2-initialize-in-the-project-root-directory" tabindex="-1">2. Initialize in the project root directory <a class="header-anchor" href="#_2-initialize-in-the-project-root-directory" aria-label="Permalink to &quot;2. Initialize in the project root directory&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo init [--typescript]</span></span></code></pre></div><p>Check if the project is built using Typescript. If so, include the <code>--typescript</code> parameter. The initialization process creates a configuration file <code>.semorc.yml</code> in the project root directory and adds a <code>bin/semo</code> directory. Theoretically, this should not conflict with the existing project.</p><h3 id="_3-add-some-commands-or-scripts" tabindex="-1">3. Add some commands or scripts <a class="header-anchor" href="#_3-add-some-commands-or-scripts" aria-label="Permalink to &quot;3. Add some commands or scripts&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo generate command xxx</span></span>\n<span class="line"><span>semo generate script yyy // Requires installing the semo-plugin-script plugin</span></span></code></pre></div><h3 id="_4-define-project-specific-plugins" tabindex="-1">4. Define project-specific plugins <a class="header-anchor" href="#_4-define-project-specific-plugins" aria-label="Permalink to &quot;4. Define project-specific plugins&quot;">​</a></h3><p>Similar to the concept of progressive development, if a plugin is only used within its own project, it can be part of the project code. Once optimized and mature, it can easily be converted into an npm package format for sharing with other projects.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>semo generate plugin zzz</span></span></code></pre></div><h3 id="_5-inject-business-code-into-the-repl-environment" tabindex="-1">5. Inject business code into the REPL environment <a class="header-anchor" href="#_5-inject-business-code-into-the-repl-environment" aria-label="Permalink to &quot;5. Inject business code into the REPL environment&quot;">​</a></h3><p>Refer to <code>Plugin Development -&gt; Example 2: Implement hook_repl</code> to see how methods are injected into the <code>REPL</code>. Note that all methods can only be injected into the REPL&#39;s Semo object; this protects the REPL&#39;s variable namespace. For business methods, simply import them and return according to the format requirements of <code>hook_repl</code>. To make the methods effective, you also need to handle their environmental dependencies yourself, such as database connections, etc.</p>',19)]))}const m=a(i,[["render",o]]);export{h as __pageData,m as default};
