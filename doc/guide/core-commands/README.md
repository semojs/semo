# 核心命令

## `zignis application`

> alias: `app`

默认这个命令没有任何功能，存在的意思是跟业务项目建立一个约定，建议业务项目添加的命令都写成这个命令的子命令。而业务项目之所以能为这个命令添加子命令是利用了 `Zignis` 的命令扩展机制。

```bash
zignis make command application/test --extend=zignis
```

这样就可以为项目添加一个 test 命令，而这个命令在执行的时候需要使用 `zignis application test` 的方式来调用。

通过 `zignis application help` 可以看到当前业务项目定义的所有顶级子命令，因为如果项目实现的命令过多，层次也多的话，一般我们很难记住所有命令和参数，所以帮助命令是我们经常要执行的。

## `zignis hook`

这个命令的输出显示了当前环境下可用的所有的钩子，所有实现这些钩子的逻辑都可以被执行。在输出当中能够看到钩子的名称，描述，以及钩子在哪个模块声明的：

```
╔══════════════════════╤═════════════════════╤════════════════════════════════════════════════════╗
║ Hook                 │ Package             │ Description                                        ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_beforeCommand   │ zignis              │ Hook triggered before command execution.           ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_afterCommand    │ zignis              │ Hook triggered after command execution.            ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_components      │ zignis              │ Hook triggered when needing to fetch components    ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_hook            │ zignis              │ Hook triggered in hook command.                    ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_repl            │ zignis              │ Hook triggered in repl command.                    ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_status          │ zignis              │ Hook triggered in status command.                  ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_new_repo        │ zignis              │ Hook triggered in new command.                     ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_zhike_cron      │ zignis-plugin-zhike │ Hook triggered in zignis zhike cron command        ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_zhike_component │ zignis-plugin-zhike │ Hook triggered when zhike hook_components invoked  ║
╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢
║ hook_zhike_repl      │ zignis-plugin-zhike │ Hook triggered when zhike hook_repl invoked        ║
╚══════════════════════╧═════════════════════╧════════════════════════════════════════════════════╝
```

这里可以看到有一个特殊的钩子是 `hook_hook` 实现这个钩子就可以声明钩子，任何插件都可以声明自己的钩子，让其他命令来调用，从而影响自身的行为，一般业务项目是不需要声明自己的钩子的，除非业务项目深度使用了这个机制，来构成自己业务的插件系统。

另外需要注意的是，即使不声明，钩子也是可以被使用的，只要其被实现了，这里声明钩子只是为了透明。具体如何声明和实现钩子将在钩子相关章节说明。

::: warning
这里未来有可能改成不声明的钩子不让使用的逻辑
:::

## `zignis init`

这个命令用来做初始化，可以实现两种场景，对业务项目的初始化或者对插件的初始化，这两个场景的差别在于目录结构稍有差异。

业务项目中，我们默认将 `Zignis` 的目录结构放到 `bin` 目录:

```
├── .zignisrc.json
├── bin
│   └── zignis
│       ├── commands
│       ├── extends
│       ├── hooks
│       ├── plugins
│       └── scripts
└── package.json

```

而在插件项目中，我们是把所有代码放到 `src` 目录:

```
├── .zignisrc.json
├── src
│    ├── commands
│    ├── extends
│    ├── hooks
└── package.json
```

这个命令存在的意义也仅仅是为了节省工程师若干秒的时间，也就是说如果不用这个命令，手动去创建这些目录和文件夹也是 OK 的。

:::tip
关于 `.zignisrc.json` 的结构和用途将在配置管理章节说明
:::

另外，如果我们真的要创建一个插件，通过初始化的方式进行还是太慢了，这里推荐使用插件项目模板进行，具体的命令如下：

```
zignis new zignis-plugin-xxx --select=plugin
```

很明显这里还可以使用其他项目模板，关于 `new` 命令，参见下放关于 `new` 命令的介绍。