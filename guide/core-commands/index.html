<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>核心命令 | Semo</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="一个Node项目命令行开发规范">
    <link rel="preload" href="/assets/css/0.styles.9bcdb81a.css" as="style"><link rel="preload" href="/assets/js/app.6defaefe.js" as="script"><link rel="preload" href="/assets/js/2.27785afd.js" as="script"><link rel="preload" href="/assets/js/10.100790e3.js" as="script"><link rel="prefetch" href="/assets/js/11.229097e0.js"><link rel="prefetch" href="/assets/js/12.2d016466.js"><link rel="prefetch" href="/assets/js/13.13ed3765.js"><link rel="prefetch" href="/assets/js/14.0871fcc3.js"><link rel="prefetch" href="/assets/js/15.523813ed.js"><link rel="prefetch" href="/assets/js/16.534ae758.js"><link rel="prefetch" href="/assets/js/17.e11b1ccc.js"><link rel="prefetch" href="/assets/js/3.3ddec59a.js"><link rel="prefetch" href="/assets/js/4.2b7fc900.js"><link rel="prefetch" href="/assets/js/5.889db759.js"><link rel="prefetch" href="/assets/js/6.e863ce1f.js"><link rel="prefetch" href="/assets/js/7.9056e456.js"><link rel="prefetch" href="/assets/js/8.8110660e.js"><link rel="prefetch" href="/assets/js/9.fbbf1895.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9bcdb81a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Semo</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  指南
</a></div><div class="nav-item"><a href="/usage/" class="nav-link">
  用法
</a></div><div class="nav-item"><a href="http://semo.js.org/typedoc/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  参考
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/semojs/semo" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  指南
</a></div><div class="nav-item"><a href="/usage/" class="nav-link">
  用法
</a></div><div class="nav-item"><a href="http://semo.js.org/typedoc/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  参考
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/semojs/semo" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/" aria-current="page" class="sidebar-link">介绍</a></li><li><a href="/guide/quickstart/" class="sidebar-link">快速上手</a></li><li><a href="/guide/core-commands/" aria-current="page" class="active sidebar-link">核心命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-application" class="sidebar-link">semo application</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-config" class="sidebar-link">semo config</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-hook" class="sidebar-link">semo hook</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-init" class="sidebar-link">semo init</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-create-name-repo-branch" class="sidebar-link">semo create  [repo] [branch]</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-generate-component" class="sidebar-link">semo generate &lt;component&gt;</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-plugin" class="sidebar-link">semo plugin</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-repl" class="sidebar-link">semo repl</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-run-plugin-command" class="sidebar-link">semo run  [COMMAND]</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-script-file" class="sidebar-link">semo script [file]</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-shell" class="sidebar-link">semo shell</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-status" class="sidebar-link">semo status</a></li><li class="sidebar-sub-header"><a href="/guide/core-commands/#semo-completion" class="sidebar-link">semo completion</a></li></ul></li><li><a href="/guide/config/" class="sidebar-link">配置管理</a></li><li><a href="/guide/plugin/" class="sidebar-link">插件开发</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>用法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/usage/" class="sidebar-link">概述</a></li><li><a href="/usage/plugin/" class="sidebar-link">插件</a></li><li><a href="/usage/integration/" class="sidebar-link">项目整合</a></li><li><a href="/usage/solution/" class="sidebar-link">解决方案</a></li><li><a href="/usage/distribution/" class="sidebar-link">发行版</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>社区</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/community/contrib/" class="sidebar-link">如何贡献</a></li><li><a href="/community/qa/" class="sidebar-link">常见问题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="核心命令"><a href="#核心命令" class="header-anchor">#</a> 核心命令</h1> <h2 id="semo-application"><a href="#semo-application" class="header-anchor">#</a> <code>semo application</code></h2> <blockquote><p>alias: <code>app</code></p></blockquote> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这条命令已经转移到 <code>semo-plugin-application</code> 插件</p></div> <p>默认这个命令没有任何功能，存在的意思是跟业务项目建立一个约定，建议业务项目添加的命令都写成这个命令的子命令。而业务项目之所以能为这个命令添加子命令是利用了 <code>Semo</code> 的命令扩展机制。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> semo-plugin-application
semo generate <span class="token builtin class-name">command</span> application/test --extend<span class="token operator">=</span>application
</code></pre></div><p>这样就可以为项目添加一个 test 命令，而这个命令在执行的时候需要使用 <code>semo application test</code> 的方式来调用。</p> <p>通过 <code>semo application help</code> 可以看到当前业务项目定义的所有顶级子命令，因为如果项目实现的命令过多，层次也多的话，一般我们很难记住所有命令和参数，所以帮助命令是我们经常要执行的。</p> <h2 id="semo-config"><a href="#semo-config" class="header-anchor">#</a> <code>semo config</code></h2> <p>我们可以通过核心内置的这个命令来查看和修改配置文件，可以操作当前项目的配置文件，也可以操作全局配置文件。</p> <div class="language- extra-class"><pre class="language-text"><code>semo config &lt;op&gt;

Manage rc config

命令：
  semo config delete &lt;configKey&gt;                                Delete configs by key                     [aliases: del]
  semo config get &lt;configKey&gt;                                   Get configs by key
  semo config list                                              List configs                   [默认值] [aliases: ls, l]
  semo config set &lt;configKey&gt; &lt;configValue&gt; [configComment]     Set config by key
  [configType]

Options:
  --global, -g  For reading/writing configs from/to global yml rc file, default is false
  --watch       Watch config change, maybe only work on Mac
</code></pre></div><p>注意，这里的 <configKey> 的格式是 <code>a.b.c</code> 的形式，代表多层级配置。另外，这里支持对设置的最后一个层级的配置添加注释。</configKey></p> <h2 id="semo-hook"><a href="#semo-hook" class="header-anchor">#</a> <code>semo hook</code></h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这条命令已经转移到 <code>semo-plugin-hook</code> 插件</p></div> <p>这个命令的输出显示了当前环境下可用的所有的钩子，所有实现这些钩子的逻辑都可以被执行。在输出当中能够看到钩子的名称，描述，以及钩子在哪个模块声明的：</p> <div class="language- extra-class"><pre class="language-text"><code>Hook                         :  Package :  Description                                     
  hook_beforeCommand           :  semo    :  Hook triggered before command execution.        
  hook_afterCommand            :  semo    :  Hook triggered after command execution.         
  hook_component               :  semo    :  Hook triggered when needing to fetch component 
  hook_hook                    :  semo    :  Hook triggered in hook command.                 
  hook_repl                    :  semo    :  Hook triggered in repl command.                 
  hook_status                  :  semo    :  Hook triggered in status command.               
  hook_create_project_template :  semo    :  Hook triggered in create command.  
</code></pre></div><p>这里可以看到有一个特殊的钩子是 <code>hook_hook</code> 实现这个钩子就可以声明钩子，任何插件都可以声明自己的钩子，让其他命令来调用，从而影响自身的行为，一般业务项目是不需要声明自己的钩子的，除非业务项目深度使用了这个机制，来构成自己业务的插件系统。</p> <p>另外需要注意的是，即使不声明，钩子也是可以被使用的，只要其被实现了，这里声明钩子只是为了透明。具体如何声明和实现钩子将在钩子相关小节说明。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>这里未来有可能改成不声明的钩子不让使用的逻辑</p></div> <h2 id="semo-init"><a href="#semo-init" class="header-anchor">#</a> <code>semo init</code></h2> <blockquote><p>alias: <code>i</code></p></blockquote> <p>这个命令用来做初始化，可以实现两种场景，对业务项目的初始化或者对插件的初始化，这两个场景的差别在于目录结构稍有差异。</p> <p>业务项目中，我们默认将 <code>Semo</code> 的目录结构放到 <code>bin</code> 目录:</p> <div class="language- extra-class"><pre class="language-text"><code>├── .semorc.yml
├── bin
│   └── semo
│       ├── commands
│       ├── extends
│       ├── hooks
│       ├── plugins
│       └── scripts
└── package.json

</code></pre></div><p>而在插件项目中，我们是把所有代码放到 <code>src</code> 目录:</p> <div class="language- extra-class"><pre class="language-text"><code>├── .semorc.yml
├── src
│    ├── commands
│    ├── extends
│    ├── hooks
└── package.json
</code></pre></div><p>这个命令存在的意义也仅仅是为了节省工程师若干秒的时间，也就是说如果不用这个命令，手动去创建这些目录和文件夹也是 OK 的。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>关于 <code>.semorc.yml</code> 的结构和用途将在配置管理小节说明</p></div> <p>另外，如果我们真的要创建一个插件，通过初始化的方式进行还是太慢了，这里推荐使用插件项目模板进行，具体的命令如下：</p> <div class="language- extra-class"><pre class="language-text"><code>semo create semo-plugin-xxx --template=plugin
</code></pre></div><p>很明显这里还可以使用其他项目模板，关于 <code>create</code> 命令，参见下放关于 <code>create</code> 命令的介绍。</p> <h2 id="semo-create-name-repo-branch"><a href="#semo-create-name-repo-branch" class="header-anchor">#</a> <code>semo create &lt;name&gt; [repo] [branch]</code></h2> <blockquote><p>alias: <code>n</code></p></blockquote> <p>这个命令和 <code>generate</code> 以及 <code>init</code> 都不一样，是用来初始化一个新的项目目录的，这个项目可以是业务项目，也可以是一个插件。这个命令有很多参数，也有一些约定：</p> <div class="language- extra-class"><pre class="language-text"><code>$ semo create help

semo create &lt;name&gt; [repo] [branch]

Create a create project from specific repo

选项：
  --version      显示版本号                                                                                       [布尔]
  --yarn         use yarn command                                                                        [默认值: false]
  --yes, -y      run npm/yarn init with --yes                                                             [默认值: true]
  --force, -F    force download, existed folder will be deleted!
  --merge, -M    merge config with exist project folder!
  --empty, -E    force empty project, ignore repo
  --template, -T   select from default repos
  --add, -A      add npm package to package.json dependencies                                            [默认值: false]
  --add-dev, -D  add npm package to package.json devDependencies                                         [默认值: false]
  --init-semo, -i     init new project
  -h, --help     显示帮助信息                                                                                     [布尔]
</code></pre></div><p>单个的说明上面已经有了，下面我们用具体的使用场景说明一下</p> <h3 id="从任意代码仓库初始化"><a href="#从任意代码仓库初始化" class="header-anchor">#</a> 从任意代码仓库初始化</h3> <div class="language- extra-class"><pre class="language-text"><code>semo create PROJECT_NAME PROJECT_REPO_URL master -f
</code></pre></div><p>这里可以看出，我们用 create 命令可以从任意 git 仓库地址下载代码，任何代码仓库都可以是我们的项目模板。其中 <code>master</code> 是分支名，默认就是 <code>master</code> 所以可以省略，<code>-f</code> 的意思是如果目录已经存在，会先删除原来的，再重新创建。</p> <p>create 命令除了把代码下载下来，还帮着把原来的 <code>.git</code> 目录删除了，并且重新初始化了一个空的 <code>.git</code> 目录，然后把项目的依赖都自动下载下来了。</p> <h3 id="创建一个空项目，不基于任何项目模板"><a href="#创建一个空项目，不基于任何项目模板" class="header-anchor">#</a> 创建一个空项目，不基于任何项目模板</h3> <div class="language- extra-class"><pre class="language-text"><code>semo create PROJECT_NAME -yfie
</code></pre></div><p>这里可以看到一个 <code>yargs</code> 的特性，可以把短参数连起来用，这里相当于 <code>-y -f -i -e</code>，也就是，<code>-y</code> 帮我们在创建了 <code>package.json</code>时自动回答 <code>yes</code>，<code>-f</code> 是强制删除已存在的目录，<code>-i</code> 是自动执行 <code>semo init</code> 初始化项目目录， <code>-e</code> 是告诉命令，即不基于代码仓库，也不基于内置模板，而是要声明一个空项目。</p> <p>项目的目录结构如下：</p> <div class="language- extra-class"><pre class="language-text"><code>├── .semorc.yml
├── bin
│   └── semo
│       ├── commands
│       ├── extends
│       ├── hooks
│       ├── plugins
│       └── scripts
└── package.json
</code></pre></div><h3 id="创建一个-semo-插件目录"><a href="#创建一个-semo-插件目录" class="header-anchor">#</a> 创建一个 <code>Semo</code> 插件目录</h3> <p>如果不基于插件模板，我们可以手动创建一个基本的插件结构：</p> <div class="language- extra-class"><pre class="language-text"><code>semo create semo-plugin-[PLUGIN_NAME] -yfie
</code></pre></div><p>可以看到，和上面很类似，除了项目名，这里存在一个项目名称的约定，如果项目名称以 <code>semo-plugin-</code> 开头，则认为是在初始化一个 <code>Semo</code> 插件，初始化时会执行 <code>semo init --plugin</code>。</p> <p>项目的目录结构如下：</p> <div class="language- extra-class"><pre class="language-text"><code>├── .semorc.yml
├── package.json
└── src
    ├── commands
    ├── extends
    └── hooks
</code></pre></div><h3 id="基于内置模板创建项目"><a href="#基于内置模板创建项目" class="header-anchor">#</a> 基于内置模板创建项目</h3> <p>如果我们创建项目执行下面的命令:</p> <div class="language- extra-class"><pre class="language-text"><code>semo create PROJECT_NAME --template
</code></pre></div><p>则会看到下面的输出:</p> <div class="language- extra-class"><pre class="language-text"><code>? Please choose a pre-defined repo to continue: (Use arrow keys)
❯ semo_plugin_starter [semo-plugin-starter, plugin]
❯ ...
</code></pre></div><p>这里可以选择一个想要选择的内置模板，也就是不用主动输入仓库地址了，这里默认只有一个插件模板，但是可以使用 <code>hook_create_project_template</code> 注入其他模板地址进去：</p> <p>钩子实现示例，更多关于钩子的用法，请参见钩子相关说明</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> hook_create_project_template <span class="token operator">=</span> <span class="token punctuation">{</span>
  demo_repo<span class="token operator">:</span> <span class="token punctuation">{</span>
    repo<span class="token operator">:</span> <span class="token string">'demo_repo.git'</span><span class="token punctuation">,</span>
    branch<span class="token operator">:</span> <span class="token string">'master'</span><span class="token punctuation">,</span>
    alias<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'demo'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果在初始化的时候已经知道要使用的模板和标识，可以直接指定：</p> <div class="language- extra-class"><pre class="language-text"><code>semo create PROJECT_NAME --template=demo
semo create PROJECT_NAME --template=demo_repo
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在创建业务项目或者插件时，不推荐从空项目开始，因为还要考虑很多工程化的问题，技术选型的问题，推荐归纳总结自己公司常用的脚手架项目，然后通过统一的方式进行初始化。比如内置的插件模板，初始化后，可以直接编写逻辑，然后代码上传到 <code>Github</code> 再执行 <code>npm version patch &amp;&amp; npm publish</code> 即可发布到 npm 仓库了。关于如何开发一个插件并且发布到 <code>npm</code> 仓库，会单独写文档说明。另外，需要注意，这里的脚手架项目可以是任意语言实现的。</p></div> <p>剩余的其他几个选项也很好理解，<code>--yarn</code> 声明项目使用 <code>yarn</code> 来初始化和安装依赖，<code>--add</code> 和 <code>--add-dev</code> 用来在初始化时指定新的依赖包。<code>--merge</code> 是说不删除原来的项目，而是进入项目目录，然后应用 <code>--init</code>, <code>--add</code>, <code>--add-dev</code>。</p> <h2 id="semo-generate-component"><a href="#semo-generate-component" class="header-anchor">#</a> <code>semo generate &lt;component&gt;</code></h2> <blockquote><p>alias: <code>generate</code>, <code>g</code></p></blockquote> <p>这个命令是一个组件代码生成命令，这里组件的意思是对开发目标进行抽象的后的分层分类概念，比如 <code>Semo</code> 核心就定义了插件，命令和脚本3个概念，所以这三个概念有对应的代码生成子命令，同样的，<code>semo</code> 插件或者集成的项目都可以创建自己的抽象概念，并提供配套的代码生成器，比如业务项目后端会有路由，控制器，模型，数据库迁移文件，单元测试等概念，这些概念由于项目的不同可能是不通用的，但是一个项目内部最好风格保持一致，通过自动生成样板代码可以更好的保持风格一致。</p> <div class="language- extra-class"><pre class="language-text"><code>$ semo generate help

semo generate &lt;component&gt;

Generate component sample code

命令：
  semo generate command &lt;name&gt; [description]               Generate a command template
  semo generate plugin &lt;name&gt;                              Generate a plugin structure
  semo generate script &lt;name&gt;                              Generate a script file

选项：
  --version   显示版本号                                                                                          [布尔]
  -h, --help  显示帮助信息                                                                                        [布尔]
</code></pre></div><h3 id="扩展-generate-命令添加子命令"><a href="#扩展-generate-命令添加子命令" class="header-anchor">#</a> 扩展 <code>generate</code> 命令添加子命令</h3> <p>和上面扩展 <code>application</code> 命令的方法是一样的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>semo generate <span class="token builtin class-name">command</span> generate/test --extend<span class="token operator">=</span>semo
</code></pre></div><p>具体怎么实现这些代码生成命令，这里是没有做约束的，因为首先 es6 内置的模板字符串机制可以解决大多数问题，然后 <code>Semo</code> 还内置了 <code>lodash</code>，其 <code>_.template</code> 方法也比较灵活，最后只要把组装好的样板代码放到想放的位置即可。</p> <p>因为这部分都是基于 <code>Semo</code> 的，所以相关的配置建议放到 <code>.semorc.yml</code> 文件，例如自动生成的配置里就有的：</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">commandDir</span><span class="token punctuation">:</span> src/commands
<span class="token key atrule">extendDir</span><span class="token punctuation">:</span> src/extends
<span class="token key atrule">hookDir</span><span class="token punctuation">:</span> src/hooks
</code></pre></div><p>可以看到，<code>create</code> 命令生成默认配置也仅仅是约定了一些代码自动生成的目录，同时也给出一种定义目录的配置风格，如果想保持配置的一致性，可以用同样的风格定义其他目录。</p> <h2 id="semo-plugin"><a href="#semo-plugin" class="header-anchor">#</a> <code>semo plugin</code></h2> <blockquote><p>alias: p</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这条命令已经转移到 <code>semo-plugin-plugin</code> 插件</p></div> <p>这个命令用于安装在家目录的全局插件，也可以用于优化当前项目的 semo 执行效率。</p> <div class="language- extra-class"><pre class="language-text"><code>$ semo plugin help
semo plugin

Plugin management tool

命令：
  semo p install &lt;plugin&gt;    Install plugin                                                                 [aliases: i]
  semo p list                List all plugins                                                           [aliases: l, ls]
  semo p uninstall &lt;plugin&gt;  Uninstall plugin                                                              [aliases: un]
</code></pre></div><h2 id="semo-repl"><a href="#semo-repl" class="header-anchor">#</a> <code>semo repl</code></h2> <blockquote><p>alias: <code>r</code></p></blockquote> <p>REPL(read-eval-print-loop)：交互式解析器，每一个现代的编程语言大概都有这类交互环境，在里面我们可以写一些简单的代码，做为一个快速了解和学习语言特性的工具。但是当 REPL 可以和框架或者业务项目结合以后，可以发挥出更大的作用。</p> <h3 id="对-repl-的一些扩展"><a href="#对-repl-的一些扩展" class="header-anchor">#</a> 对 <code>REPL</code> 的一些扩展</h3> <p>默认 REPL 的退出只能通过 <code>ctrl+c</code> 或者 <code>ctrl+d</code> 或者 <code>.exit</code> 来进行，这里我们加入了几个快捷的命令，<code>quit</code>, <code>q</code>, <code>exit</code>。</p> <p>在开发Semo 和这个脚手架时，Node 的 REPL 还不支持 <code>await</code>，这里是模拟实现了这个机制，目的是可以触发执行项目中的一些 promise 或 generator 方法。通过这个能力，再加上我们可以把一些业务代码注入到 <code>REPL</code> 我们就可以在接口控制器，脚本，单元测试之外多了一种执行方式，而这种执行方式还是交互式的。</p> <h3 id="为-repl-注入新的对象"><a href="#为-repl-注入新的对象" class="header-anchor">#</a> 为 <code>REPL</code> 注入新的对象</h3> <p>这里需要实现内置的 <code>hook_repl</code> 钩子，并且在业务项目的声明的钩子目录配置： <code>hookDir</code>，下面代码仅供参考。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/hooks/index.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">hook_repl</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">add</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> a <span class="token operator">+</span> b
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">multiple</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> a <span class="token operator">*</span> b
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>然后在 REPL 环境，就可以使用了:</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>hook_repl</code> 返回的信息都注入到了 REPL 里的 Semo 对象。</p></div> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt;&gt; add
[Function: add]
&gt;&gt;&gt; await Semo.add(1, 2)
3
&gt;&gt;&gt; multiple
[Function: multiple]
&gt;&gt;&gt; await Semo.multiple(3, 4)
12
</code></pre></div><p>在实际的业务项目中，会把项目中的公共方法，工具函数等等都注入进去，这对开发以及后面的排查问题都是很有帮助的。默认 <code>Semo</code> 把自己的 <code>Utils</code> 工具对象注入进去了，里面有一些是 <code>Semo</code> 自定义的工具函数，更多的是把 <code>Semo</code> 引入的依赖包暴露出来，比如 <code>lodash</code>。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在具体的实践中，我们把数据库，缓存，OSS，Consul, ElasticSearch 等等多种公司的基础设施注入了进来，写成插件，使得我们更容易的直接访问基础设施。</p></div> <h2 id="semo-run-plugin-command"><a href="#semo-run-plugin-command" class="header-anchor">#</a> <code>semo run &lt;PLUGIN&gt; [COMMAND]</code></h2> <p>这个命令可以像 yarn create 一样，实现直接执行远程插件包里的命令的效果</p> <p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>semo run semo-plugin-serve serve
</code></pre></div><p>这里是调用了 semo-plugin-serve 插件实现简单的 HTTP 服务，也许我们会觉得这样写起来还是不是很方便，那么我们可以简化一下。</p> <div class="language- extra-class"><pre class="language-text"><code>semo run serve
</code></pre></div><p>这样看是不是简洁多了，这里能把 <code>semo-plugin-</code> 省略的原因是这里只支持 semo 系列插件，而不是所有的 npm 包，所以可以内部帮着加上，而后面的 serve 命令去掉是因为插件为此实现了一个约定，插件就是一个普通的 node 包，可以对外暴露方法，这里暴露了一个 handler 方法，而这个 handler 方法又去掉了包里的 serve 命令，因为这个命令文件也是一个 Node 模块。如果插件里面包含多个命令，可以用这个机制对外暴露最常用的，其他的还是应该明确传参。另外，需要注意的是一些命令需要传递参数，这里需要把所有的参数和选项都改造成选项。</p> <p>之前是命令的时候：</p> <div class="language- extra-class"><pre class="language-text"><code>semo serve [publicDir]
</code></pre></div><p>在用 <code>run</code> 命令调度时：</p> <div class="language- extra-class"><pre class="language-text"><code>semo run serve --public-dir=.
</code></pre></div><p>如果你在 npm 的 semo 插件包也是在 scope 下的，在用 run 时需要指定 scope</p> <div class="language- extra-class"><pre class="language-text"><code>semo run xxx --SCOPE yyy
</code></pre></div><p><code>run</code> 命令运行的插件肯定是缓存到本地了，只不过不在全局插件目录 <code>.semo/node_modules</code>, 而是在 <code>.semo/run_plugin_cache/node_modules</code> 目录，默认如果存在就会用缓存里的插件，如果想更新需要用参数 --upgrade</p> <div class="language- extra-class"><pre class="language-text"><code>semo run serve --UPGRADE
</code></pre></div><p>你可能已经发现这个命令的所有参数和选项都是大写的，这是为了减少与其他插件的冲突，我们最好约定所有的插件的参数和选项都用小写。</p> <h2 id="semo-script-file"><a href="#semo-script-file" class="header-anchor">#</a> <code>semo script [file]</code></h2> <blockquote><p>alias: <code>scr</code></p></blockquote> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这条命令已经转移到 <code>semo-plugin-script</code> 插件</p></div> <p>很多时候我们都需要跑一些脚本，这些脚本是在项目服务之外的，需要我们主动触发，可能是做数据迁移，可能是数据导出，可能是数据批量修改，也可能是执行业务逻辑，比如发邮件，发短信，发通知等等。在遇到这样的需求的时候，我们都需要写脚本，但是我们会遇到几个问题：</p> <ul><li>放哪里</li> <li>怎么写</li> <li>脚本参数怎么解析</li></ul> <p>很多时候这些需求都是一次性的，或者有前提的，不是很适合写成命令，不然命令就太多了，在这种场景下，<code>Semo</code> 通过这条命令给出了一个统一的方案。</p> <h3 id="放哪里"><a href="#放哪里" class="header-anchor">#</a> 放哪里</h3> <p>在配置中有一个 <code>scriptDir</code>，默认是 <code>src/scripts</code>，我们默认把脚本都放到这里，因为这些脚本不会被服务访问到，所以没必要和项目核心逻辑放的太近。</p> <h3 id="怎么写，怎么解析参数"><a href="#怎么写，怎么解析参数" class="header-anchor">#</a> 怎么写，怎么解析参数</h3> <p>当然可以手动建脚本，然后用这个命令来触发，但是因脚本还需要起名字，而且还有一定的格式要求，所以，推荐使用 <code>semo generate script</code> 命令来生成。</p> <div class="language- extra-class"><pre class="language-text"><code>semo generate script test
</code></pre></div><p>自动生成的样板代码及文件名：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/bin/semo/scripts/20191025130716346_test.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">builder</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">yargs<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// yargs.option('option', {default, describe, alias})</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">argv<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Start to draw your dream code!'</span><span class="token punctuation">)</span>
  process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，作为一个脚本，不是一上来就写业务逻辑，也不需要声明 <code>shebang</code> 标识，只需要定义两个方法，一个是 <code>builder</code>，一个是 <code>handler</code>。其中 <code>builder</code> 用于声明脚本的参数，格式可以参考 <code>yargs</code>，如果脚本不需要参数，其实也可以不定义，由于是模板自动生成，放到那里即可，以备不时之需。<code>handler</code> 是具体的执行逻辑，传入的参数就是解析好的脚本参数，也包含了项目的 <code>.semorc.yml</code> 里的配置。可以看到 <code>handler</code> 支持 <code>async</code> 所以这里可以执行一些异步操作。</p> <p>所以，脚本和命令最大的区别其实就是使用的频率，以及业务的定位，我们经常做的分层是定义原子命令，然后在脚本中调度。</p> <h2 id="semo-shell"><a href="#semo-shell" class="header-anchor">#</a> <code>semo shell</code></h2> <blockquote><p>alias: <code>sh</code></p></blockquote> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这条命令已经转移到 <code>semo-plugin-shell</code> 插件</p></div> <p>这个命令是个很简单的命令，目的是不用每次敲命令都输入前面的 <code>semo</code>，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>semo shell
&gt; status
&gt; hook
&gt; repl
</code></pre></div><p>这个命令平时的使用频率不是很高，但是也许有一些人会喜欢使用。退出和 <code>repl</code> 命令一样支持：<code>q</code>, <code>quit</code>, <code>exit</code>。这里还有个额外的用法是，你也可以修改前缀，对其他多层级的命令行工具实现类似的效果，比如:</p> <div class="language- extra-class"><pre class="language-text"><code>semo shell --prefix=git
&gt; log
&gt; remote -v
</code></pre></div><h2 id="semo-status"><a href="#semo-status" class="header-anchor">#</a> <code>semo status</code></h2> <blockquote><p>alias: <code>st</code></p></blockquote> <p>这个命令的作用很简单，就是看 <code>Semo</code> 当前所处的环境，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>$ semo st
  version  :  1.8.17
  location :  ~/.nvm/versions/node/[VERSION]/lib/node_modules/semo
  os       :  macOS 10.15
  node     :  8.16.2
  npm      :  6.4.1
  yarn     :  1.15.2
  hostname :  [MY_HOST]
  home     :  [MY_HOME]
  shell    :  [MY_SHELL]
</code></pre></div><p>这里实现了一个 hook， <code>hook_status</code>，实现了这个 hook 的插件，可以在这里展示插件的相关信息，如果是业务项目实现了这个钩子，也可以在这里显示项目信息。</p> <h2 id="semo-completion"><a href="#semo-completion" class="header-anchor">#</a> <code>semo completion</code></h2> <p>这个命令的作用是输出一段 <code>Shell</code> 脚本，放到 <code>.bashrc</code> 或者 <code>.zshrc</code> 里，就能够获得子命令的自动补全效果。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>由于 <code>Semo</code> 的性能有些差，所以这个自动补全虽然能用，但是体验极差，不建议使用。</p></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/semojs/semo/edit/master/docs/guide/core-commands/README.md" target="_blank" rel="noopener noreferrer">帮助改进此页文档</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/quickstart/" class="prev">
        快速上手
      </a></span> <span class="next"><a href="/guide/config/">
        配置管理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6defaefe.js" defer></script><script src="/assets/js/2.27785afd.js" defer></script><script src="/assets/js/10.100790e3.js" defer></script>
  </body>
</html>
