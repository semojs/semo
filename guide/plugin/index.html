<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>插件开发 | Semo</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="一个Node项目命令行开发规范">
    
    <link rel="preload" href="/assets/css/0.styles.992cb7aa.css" as="style"><link rel="preload" href="/assets/js/app.396b332a.js" as="script"><link rel="preload" href="/assets/js/2.eb14a998.js" as="script"><link rel="preload" href="/assets/js/15.d5919497.js" as="script"><link rel="prefetch" href="/assets/js/10.8fd9f964.js"><link rel="prefetch" href="/assets/js/11.701520b5.js"><link rel="prefetch" href="/assets/js/12.9189bd7b.js"><link rel="prefetch" href="/assets/js/13.61a2dd2b.js"><link rel="prefetch" href="/assets/js/14.a0c4fac3.js"><link rel="prefetch" href="/assets/js/16.1211fef7.js"><link rel="prefetch" href="/assets/js/17.b3f6e527.js"><link rel="prefetch" href="/assets/js/18.60fb3188.js"><link rel="prefetch" href="/assets/js/19.03b2542a.js"><link rel="prefetch" href="/assets/js/20.f3634b13.js"><link rel="prefetch" href="/assets/js/21.c7a67ea5.js"><link rel="prefetch" href="/assets/js/3.7e9f8e55.js"><link rel="prefetch" href="/assets/js/4.6fd1ef01.js"><link rel="prefetch" href="/assets/js/5.da37f56e.js"><link rel="prefetch" href="/assets/js/6.d09cb291.js"><link rel="prefetch" href="/assets/js/7.81a6e97e.js"><link rel="prefetch" href="/assets/js/8.ebf1bc1e.js"><link rel="prefetch" href="/assets/js/9.57937262.js">
    <link rel="stylesheet" href="/assets/css/0.styles.992cb7aa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Semo</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  指南
</a></div><div class="nav-item"><a href="/usage/" class="nav-link">
  用法
</a></div><div class="nav-item"><a href="http://semo.js.org/typedoc/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  参考
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/semojs/semo" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  指南
</a></div><div class="nav-item"><a href="/usage/" class="nav-link">
  用法
</a></div><div class="nav-item"><a href="http://semo.js.org/typedoc/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  参考
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/semojs/semo" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/" aria-current="page" class="sidebar-link">介绍</a></li><li><a href="/guide/quickstart/" class="sidebar-link">快速上手</a></li><li><a href="/guide/core-commands/" class="sidebar-link">核心命令</a></li><li><a href="/guide/custom-commands/" class="sidebar-link">自定义命令</a></li><li><a href="/guide/config/" class="sidebar-link">配置管理</a></li><li><a href="/guide/hook/" class="sidebar-link">钩子机制</a></li><li><a href="/guide/plugin/" aria-current="page" class="active sidebar-link">插件开发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/plugin/#快速开始" class="sidebar-link">快速开始</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#添加命令" class="sidebar-link">添加命令</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#实现钩子" class="sidebar-link">实现钩子</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#暴露方法" class="sidebar-link">暴露方法</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#发布插件" class="sidebar-link">发布插件</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#插件的层级" class="sidebar-link">插件的层级</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#直接运行远程插件" class="sidebar-link">直接运行远程插件</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#特殊的家目录插件" class="sidebar-link">特殊的家目录插件</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#识别任意目录里的插件" class="sidebar-link">识别任意目录里的插件</a></li><li class="sidebar-sub-header"><a href="/guide/plugin/#插件的主动注册机制" class="sidebar-link">插件的主动注册机制</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>用法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/usage/" class="sidebar-link">概述</a></li><li><a href="/usage/plugin/" class="sidebar-link">插件</a></li><li><a href="/usage/integration/" class="sidebar-link">项目整合</a></li><li><a href="/usage/solution/" class="sidebar-link">解决方案</a></li><li><a href="/usage/distribution/" class="sidebar-link">发行版</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>社区</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/community/contrib/" class="sidebar-link">如何贡献</a></li><li><a href="/community/qa/" class="sidebar-link">常见问题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="插件开发"><a href="#插件开发" class="header-anchor">#</a> 插件开发</h1> <h2 id="快速开始"><a href="#快速开始" class="header-anchor">#</a> 快速开始</h2> <p><code>Semo</code> 插件就是一个标准的 <code>Node</code> 模块，只不过要符合一些目录和文件结构的约定，而这些约定往往很难记忆，所以我们为插件开发者或者工具的使用者提供了各种辅助的工具，例如代码自动生成。这里描述的是推荐的插件开发流程，但同时，在熟悉开发流程之后，也完全可以从一个空目录开始手动构建一个插件。</p> <h3 id="第一步-根据模板-创建插件目录"><a href="#第一步-根据模板-创建插件目录" class="header-anchor">#</a> 第一步：根据模板，创建插件目录</h3> <div class="language- extra-class"><pre class="language-text"><code>semo create semo-plugin-xyz --template=plugin
</code></pre></div><p>这里使用了内置的插件模板，按照之前配置管理说的，我们完全可以覆盖 <code>repo</code> 和 <code>branch</code> 选项，或者覆盖 <code>--template</code> 选项来省去每次都传默认参数。</p> <h3 id="第二步-进入插件目录-执行默认命令-证明一切正常"><a href="#第二步-进入插件目录-执行默认命令-证明一切正常" class="header-anchor">#</a> 第二步：进入插件目录，执行默认命令，证明一切正常</h3> <div class="language- extra-class"><pre class="language-text"><code>cd semo-plugin-xyz
semo hi
</code></pre></div><p>这是插件模板内置的一个命令，初始化完成后，进入目录即可执行，完成首次你与插件命令的一次对话，如果你看到它回答你 <code>Hey you!</code> 就证明已经准备好，接下来就可以写真正改变世界的脚本了。</p> <h2 id="添加命令"><a href="#添加命令" class="header-anchor">#</a> 添加命令</h2> <p>需要注意的是，这个插件模板是基于 <code>Typescript</code>，因此你需要有一些 <code>Typescript</code> 基础，然后我们开发时建议开着 <code>yarn watch</code> 命令窗口，来实时编译，一边开发一边测试。</p> <div class="language- extra-class"><pre class="language-text"><code>semo generate command xyz
</code></pre></div><p>一般插件名和插件封装的命令会有一定的关联，这里我们添加一个 <code>xyz</code> 命令，当然你也可以在之前的 <code>hi</code> 命令上修改。真正掌握了插件开发之后，默认的 <code>hi</code> 命令就应该删掉了。</p> <h2 id="实现钩子"><a href="#实现钩子" class="header-anchor">#</a> 实现钩子</h2> <p>实现钩子是开发插件的另一个目的，而钩子往往都是其他插件或者业务项目定义的，通过钩子的实现可以影响和改变其他插件的行为。</p> <p>通过这个命令查询当前环境支持哪些钩子：</p> <div class="language- extra-class"><pre class="language-text"><code>semo hook list
</code></pre></div><h3 id="例子1-实现-hook-create-project-template"><a href="#例子1-实现-hook-create-project-template" class="header-anchor">#</a> 例子1：实现 <code>hook_create_project_template</code></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/hooks/index.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> semo__hook_create_project_template <span class="token operator">=</span> <span class="token punctuation">{</span>
  demo_repo<span class="token operator">:</span> <span class="token punctuation">{</span>
    repo<span class="token operator">:</span> <span class="token string">'demo_repo.git'</span><span class="token punctuation">,</span>
    branch<span class="token operator">:</span> <span class="token string">'master'</span><span class="token punctuation">,</span>
    alias<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'demo'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过这个钩子，让我们在 <code>semo create [PROJECT] --template</code> 命令执行时可以选择自定义的项目模板，只需要记住别名，不需要记住地址；另一个好处是不需要管每个工程师个人电脑上是如何设置全局 <code>--repo</code> 选项的，只需要安装了指定的插件，那大家就都可以用相同的项目别名初始化项目了。</p> <h3 id="例子2-实现-hook-repl"><a href="#例子2-实现-hook-repl" class="header-anchor">#</a> 例子2：实现 <code>hook_repl</code></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/hooks/index.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">semo__hook_repl</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">add</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> a <span class="token operator">+</span> b
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">multiple</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> a <span class="token operator">*</span> b
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>然后在 REPL 环境，就可以使用了:</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>hook_repl</code> 返回的信息都注入到了 REPL 里的 Semo 对象。</p></div> <div class="language- extra-class"><pre class="language-text"><code>semo repl
&gt;&gt;&gt; add
[Function: add]
&gt;&gt;&gt; await Semo.add(1, 2)
3
&gt;&gt;&gt; multiple
[Function: multiple]
&gt;&gt;&gt; await Semo.multiple(3, 4)
12
</code></pre></div><p>插件和业务项目在实现这个钩子时的出发点是不一样的，业务项目一般注入的是具体的业务逻辑，而插件一般注入的是公共的方法，具有一定的复用性，比如可以注入底层服务的实例方法，常用的库等等，比如核心注入的 <code>Utils</code> 里面就包含 <code>lodash</code> 库。</p> <h2 id="暴露方法"><a href="#暴露方法" class="header-anchor">#</a> 暴露方法</h2> <p>实现插件还有一个最原始的目的，就是当做一个模块，对外暴露出实例，方法或者类库。这种情况下一方面，我们可以用标准的方式定义模块，例如：</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>由于 <code>Semo</code> 后来引入了 <code>run</code> 命令，而这个命令依赖于入口文件进行定位，因此要求 <code>Semo</code> 的插件声明一个入口，不管这个入口是否有暴露方法。</p></div> <div class="language-json extra-class"><pre class="language-json"><code><span class="token comment">// package.json</span>
<span class="token punctuation">{</span>
  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;lib/index.js&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// index.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>这种方式没有任何问题，但是一般定义这种方式的模块也不需要遵守 <code>Semo</code> 的规范，只要遵守 <code>node</code> 和 <code>npm</code> 的规范即可。这里 <code>Semo</code> 定义了另外一种暴露方法的方式。基于钩子机制。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/hooks/index.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> semo__hook_component <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token string">'b'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Utils <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@semo/core'</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> Utils<span class="token punctuation">.</span><span class="token function">invokeHook</span><span class="token punctuation">(</span><span class="token string">'semo:component'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token comment">// -&gt; 'b'</span>
</code></pre></div><p>利用这种方式，我们可以封装一些业务项目的公共方法，然后跨项目进行使用，这些公共方法普遍偏底层，比如各种中间件，或者底层服务。</p> <h2 id="发布插件"><a href="#发布插件" class="header-anchor">#</a> 发布插件</h2> <p>通过命令，钩子或者类库的扩展，我们就写好了一个 <code>Semo</code> 插件，如果想跟他人共享你的插件，需要做一些准备工作。</p> <h3 id="_1-上传代码到一个-git-仓库"><a href="#_1-上传代码到一个-git-仓库" class="header-anchor">#</a> 1. 上传代码到一个 <code>git</code> 仓库</h3> <p>如果是开源的可以选择 <code>Github</code>，如果是内部插件，就上传到内部仓库即可，可能是 <code>Github</code> 私有仓库或者公司的 <code>Gitlab</code> 仓库</p> <h3 id="_2-修改-package-json"><a href="#_2-修改-package-json" class="header-anchor">#</a> 2. 修改 <code>package.json</code></h3> <p>主要是包名，版本，协议，仓库地址，首页地址等。</p> <p>如果是内部插件，可以修改一下 <code>.npmrc</code> 文件里的 <code>registry</code> 地址。</p> <h3 id="_3-获得一个-npm-仓库的账号-并登录"><a href="#_3-获得一个-npm-仓库的账号-并登录" class="header-anchor">#</a> 3. 获得一个 npm 仓库的账号，并登录</h3> <p>如果是开源的插件，可以去 <code>https://npmjs.org</code> 去注册，如果是私有部署的 <code>npm</code> 仓库，则可以找运维获得账号</p> <div class="language- extra-class"><pre class="language-text"><code>npm login --registry=[YOUR_REGISTRY]
</code></pre></div><h3 id="_4-测试插件包"><a href="#_4-测试插件包" class="header-anchor">#</a> 4. 测试插件包</h3> <div class="language- extra-class"><pre class="language-text"><code>npm pack --dry-run
</code></pre></div><p>通过打包测试，看看包里是否包含多余的文件，调整 <code>.npmignore</code> 文件的配置。</p> <h3 id="_5-发布你的插件"><a href="#_5-发布你的插件" class="header-anchor">#</a> 5. 发布你的插件</h3> <div class="language- extra-class"><pre class="language-text"><code>npm version [patch|minor|major]
npm publish
</code></pre></div><h3 id="_6-宣传插件-分享开发心得"><a href="#_6-宣传插件-分享开发心得" class="header-anchor">#</a> 6. 宣传插件，分享开发心得</h3> <p>酒香也怕巷子深，需要写好文档，并积极宣传，让别人使用和反馈。</p> <h3 id="_7-积极维护"><a href="#_7-积极维护" class="header-anchor">#</a> 7. 积极维护</h3> <p>任何 npm 包都有可能逐渐过时，或者有安全风险，需要我们积极维护，让插件发挥本来应该发挥的作用。</p> <h2 id="插件的层级"><a href="#插件的层级" class="header-anchor">#</a> 插件的层级</h2> <p>Semo 的插件系统会扫描多个位置，以增加灵活性，每个层级对应不同的目的和限制。</p> <ul><li>通过 <code>npm install -g semo-plugin-xxx</code> 安装到全局环境，所以安装的插件命令是全局可用的，这是 <code>npm</code> 默认的全局安装包的方式。</li> <li>通过 <code>semo plugin install semo-plugin-xxx</code> 安装到家目录的 <code>.semo/home-plugin-cache</code> 目录，安装的插件命令也是全局可用的，某些情况下当前用户没有权限用 npm 的方式安装到全局，可以用这种方式。</li> <li>通过 <code>npm install semo-plugin-xxx</code> 安装到当前项目目录，这种方式的插件命令只有在当前项目才会生效。</li></ul> <p>为什么有的插件会需要安装到全局呢？因为插件不仅仅可以实现我们项目的业务需求，也可以实现我们的开发工具链，甚至可以实现一些非业务的小功能，只要有想象力，任何终端功能都可以来一波，可以是完全手写，也可以是对其他优秀项目进行封装和整合，这里的优秀项目不局限于语言和语言的扩展包仓库。</p> <h2 id="直接运行远程插件"><a href="#直接运行远程插件" class="header-anchor">#</a> 直接运行远程插件</h2> <p>这里只是一个错觉，其实还是要下载到本地，只不过下载目录是区分开的，这样就不会干扰你的实现，你可以任意测试你感兴趣的插件。</p> <div class="language- extra-class"><pre class="language-text"><code>semo run semo-plugin-serve
</code></pre></div><p>这个插件的功能是提供简单的 HTTP 服务，首次运行是会下载，以后就会复用之前下载的插件，通过 --force 来进行强制更新。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>后续会开发清理插件缓存的功能</p></div> <h2 id="特殊的家目录插件"><a href="#特殊的家目录插件" class="header-anchor">#</a> 特殊的家目录插件</h2> <blockquote><p>此特性 <code>v0.8.0</code> 引入</p></blockquote> <p>我们为了给 <code>Semo</code> 添加全局的配置，需要在 <code>~/.semo</code> 目录添加一个 <code>.semorc.yml</code> 配置文件，一旦这个配置文件建立，则 <code>.semo</code> 目录自动识别为一个全局插件（其他的全局插件都在 <code>~/.semo/home-plugin-cache</code> 目录），你可以在这个插件里定义一些你自己的命令，扩展其他插件的命令，扩展其他插件的钩子等等，这个特殊的插件在于全局可识别，同时，由于默认存在，如果你有一些逻辑是本地常用的，并且不想发布成 npm 包，则可以在这里快速开始。当然，要注意，其全局可用的特点，如果有错误，也会影响到本地全局。</p> <p>我们没有预设这个特殊插件的实现方式，也就是说你可以用 <code>js</code> 来写，也可以用 <code>typescript</code> 来写。你可以通过 <code>semo init</code> 命令来初始化基本的目录解构，也可以通过 <code>semo create .semo --template=pluging</code> 用模板重新生成一个 <code>.semo</code> 目录（需要提前备份 <code>.semo</code> 目录，之后再把里面的东西合并回来）</p> <h2 id="识别任意目录里的插件"><a href="#识别任意目录里的插件" class="header-anchor">#</a> 识别任意目录里的插件</h2> <p>我们可以看到配置文件里的 <code>pluginDir</code>，如果在命令行执行的时候手动指定这个参数，就可以起到任意指定的目的，而且还支持多个目录：</p> <div class="language- extra-class"><pre class="language-text"><code>semo help --plugin-dir=dir1 --plugin-dir=dir2
</code></pre></div><p>另外，还支持通过常量的方式指定：</p> <div class="language- extra-class"><pre class="language-text"><code>SEMO_PLUGIN_DIR=dir3 semo help

## 应用内部定义的插件在 Typescript 模式下失效的问题

这是由于 `tsc` 在编译时，只能识别 ts 和 js 相关文件，不能识别我们的 `yml` 格式，而且官方也不打算支持复制 ts 之外的文件，因为 ts 毕竟不是一个完整的构建工具，所以我们需要自己来把确实的文件拷过去，这件事用 `cpy-cli` 或者 `copyfiles` 都可以实现，以 `copyfiles` 为例：

```json
// package.json
{
  &quot;scripts&quot;: {
    &quot;copyfiles&quot;: &quot;copyfiles -u 1 -a src/**/*.yml dist -E&quot;
  }
}
</code></pre></div><p>其中参数含义:</p> <ul><li><code>-u</code> 表示去掉一层再拷贝</li> <li><code>-a</code> 表示支持隐藏文件</li> <li><code>dist</code> 是我们 ts 的 out 目录</li> <li><code>-E</code> 表示如果什么都没有 copy 时抛异常</li></ul> <h2 id="插件的主动注册机制"><a href="#插件的主动注册机制" class="header-anchor">#</a> 插件的主动注册机制</h2> <blockquote><p><code>v1.3.0</code> 引入</p></blockquote> <p>早期的 <code>Semo</code> 只支持插件的自动注册机制，而且为了灵活性，可以在多个位置进行遍历，有一定的 IO 性能损失，所以加入了主动注册机制，一旦使用主动注册机制，则自动注册机制自动失效。</p> <h3 id="开启方法"><a href="#开启方法" class="header-anchor">#</a> 开启方法</h3> <p>在 <code>.semorc.yml</code> 的 <code>$plugins</code> 段下写插件的键值对</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">$plugins</span><span class="token punctuation">:</span>
  <span class="token key atrule">register</span><span class="token punctuation">:</span>
    <span class="token key atrule">plugin-a</span><span class="token punctuation">:</span> /绝对路径
    <span class="token key atrule">plugin-b</span><span class="token punctuation">:</span> .相对路径
    <span class="token key atrule">plugin-c</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre></div><p>支持三种风格，绝对路径和相对路径比较好理解，第三种就是用 node.js 的模块加载机制来声明。作为 key 的插件名，这里可以省略 <code>semo-plugin-</code> 前缀。另外，这里也支持家目录的简写 <code>~</code></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/semojs/semo/edit/master/docs/guide/plugin/README.md" target="_blank" rel="noopener noreferrer">帮助改进此页文档</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/hook/" class="prev">
        钩子机制
      </a></span> <span class="next"><a href="/usage/">
        概述
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.396b332a.js" defer></script><script src="/assets/js/2.eb14a998.js" defer></script><script src="/assets/js/15.d5919497.js" defer></script>
  </body>
</html>
